use crate::traits::{Model, Repository};
use crate::types::Query;
use crate::utils::{BatchOperator, DEFAULT_BATCH_SIZE};

pub trait UpdatableRepository<M: Model>: Repository<M> {
    /// Creates a SQL query to update an existing model in the database.
    ///
    /// This method constructs an UPDATE statement that will modify an existing database record
    /// to match the current state of the model. It should use the model's ID to identify
    /// the record to update and include all relevant fields in the SET clause.
    ///
    /// # Parameters
    ///
    /// * `model` - A reference to the model instance containing updated values
    ///
    /// # Returns
    ///
    /// * [`Query`] - A prepared PostgreSQL UPDATE query
    ///
    /// # Implementation Notes
    ///
    /// The query should:
    /// 1. Include a WHERE clause matching the model's ID
    /// 2. Only update columns that can be modified
    /// 3. Preserve any timestamp or audit fields as required
    fn update_query(model: &M) -> Query<'_>;

    /// Executes an update operation for a single model instance.
    ///
    /// This method takes the query generated by [`update_query`](Self::update_query) and executes it against the database.
    /// It's a higher-level wrapper that handles the actual database interaction, providing a simpler
    /// interface for updating records.
    ///
    /// # Parameters
    ///
    /// * `model` - A reference to the model instance to update
    ///
    /// # Returns
    ///
    /// * [`crate::Result<()>`](crate::Result) - Success if the update was executed, or an error if the operation failed
    ///
    /// # Implementation Details
    ///
    /// The method:
    /// 1. Gets the update query from [`update_query`](Self::update_query)
    /// 2. Executes it using the connection pool
    /// 3. Handles any potential database errors
    #[tracing::instrument(skip_all, level = "debug")]
    async fn update(&self, model: &M) -> crate::Result<()> {
        Self::update_query(model).execute(self.pool()).await?;
        Ok(())
    }

    /// Updates multiple models using the default batch size.
    ///
    /// This is a convenience wrapper around [`update_batch`](Self::update_batch) that uses [`DEFAULT_BATCH_SIZE`].
    /// It simplifies bulk update operations when the default batch size is suitable.
    ///
    /// # Parameters
    ///
    /// * `models` - An iterator yielding model instances to update
    ///
    /// # Returns
    ///
    /// * [`crate::Result<()>`](crate::Result) - Success if all updates were executed, or an error if any operation failed
    #[tracing::instrument(skip_all, level = "debug")]
    async fn update_many(&self, models: impl IntoIterator<Item = M>) -> crate::Result<()> {
        <Self as UpdatableRepository<M>>::update_batch::<DEFAULT_BATCH_SIZE>(self, models).await
    }

    /// Performs a batched update operation with a specified batch size.
    ///
    /// Similar to [`insert_batch`](crate::traits::Insertable::insert_batch), this method uses [`BatchOperator`] to efficiently process
    /// large numbers of updates in chunks, preventing memory overflow and maintaining
    /// optimal database performance.
    ///
    /// # Type Parameters
    ///
    /// * `N` - The size of each batch to process
    ///
    /// # Parameters
    ///
    /// * `models` - An iterator yielding model instances to update
    ///
    /// # Returns
    ///
    /// * [`crate::Result<()>`](crate::Result) - Success if all batches were processed, or an error if any operation failed
    ///
    /// # Performance Considerations
    ///
    /// Consider batch size carefully:
    /// - Too small: More overhead from multiple transactions
    /// - Too large: Higher memory usage and longer transaction times
    #[tracing::instrument(skip_all, level = "debug")]
    async fn update_batch<const N: usize>(
        &self,
        models: impl IntoIterator<Item = M>,
    ) -> crate::Result<()> {
        BatchOperator::<M, N>::execute_query(models, self.pool(), Self::update_query).await
    }
}