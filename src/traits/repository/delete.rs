use crate::traits::{Model, Repository};
use crate::types::Query;
use crate::utils::{BatchOperator, DEFAULT_BATCH_SIZE};

pub trait DeleteRepository<M: Model>: Repository<M> {
    /// Creates a SQL query to delete a record by its ID.
    ///
    /// This method generates a DELETE statement that will remove exactly one record
    /// from the database based on its primary key. It's designed to be both safe
    /// and efficient by using parameterized queries.
    ///
    /// # Parameters
    ///
    /// * `id` - A reference to the ID of the record to delete
    ///
    /// # Returns
    ///
    /// * [`Query`] - A prepared PostgreSQL DELETE query
    ///
    /// # Implementation Notes
    ///
    /// Consider:
    /// 1. Handling soft deletes if required
    /// 2. Checking foreign key constraints
    /// 3. Implementing cascading deletes if needed
    fn delete_query_by_id(id: &M::Id) -> Query<'_>;

    /// Removes a single record from the database by its identifier.
    ///
    /// This method executes the deletion query generated by [`delete_query_by_id`](Self::delete_query_by_id). It provides
    /// a simple interface for removing individual records while handling all necessary database
    /// interactions and error management.
    ///
    /// # Parameters
    ///
    /// * `id` - Any value that can be converted into the model's ID type
    ///
    /// # Returns
    ///
    /// * [`crate::Result<()>`](crate::Result) - Success if the deletion was executed, or an error if the operation failed
    ///
    /// # Example
    ///
    /// ```no_compile
    /// async fn remove_user(repo: &UserRepository, user_id: i32) -> crate::Result<()> {
    ///     repo.delete_by_id(user_id).await
    /// }
    /// ```
    #[tracing::instrument(skip_all, level = "debug", parent = Self::repository_span())]
    async fn delete_by_id(&self, id: impl Into<M::Id>) -> crate::Result<()> {
        Self::delete_query_by_id(&id.into())
            .execute(self.pool())
            .await?;
        Ok(())
    }

    /// Deletes multiple records using the default batch size.
    ///
    /// This is a convenience wrapper around [`delete_batch`](Repository::delete_batch) that uses [`DEFAULT_BATCH_SIZE`].
    /// It provides a simpler interface for bulk deletions when the default batch size
    /// is appropriate.
    ///
    /// # Parameters
    ///
    /// * `ids` - An iterator yielding IDs of records to delete
    ///
    /// # Returns
    ///
    /// * [`crate::Result<()>`](crate::Result) - Success if all deletions were executed, or an error if any operation failed
    #[tracing::instrument(skip_all, level = "debug", parent = Self::repository_span())]
    async fn delete_many(&self, ids: impl IntoIterator<Item = M::Id>) -> crate::Result<()> {
        <Self as DeleteRepository<M>>::delete_batch::<DEFAULT_BATCH_SIZE>(self, ids).await
    }

    /// Performs a batched deletion operation with a specified batch size.
    ///
    /// Similar to other batch operations, this method uses [`BatchOperator`] to efficiently
    /// process large numbers of deletions in chunks, maintaining optimal performance
    /// and preventing resource exhaustion.
    ///
    /// # Type Parameters
    ///
    /// * `N` - The size of each batch to process
    ///
    /// # Parameters
    ///
    /// * `ids` - An iterator yielding IDs of records to delete
    ///
    /// # Returns
    ///
    /// * [`crate::Result<()>`](crate::Result) - Success if all batches were processed, or an error if any operation failed
    ///
    /// # Implementation Details
    ///
    /// The method:
    /// 1. Chunks the input IDs into batches of size N
    /// 2. Processes each batch in a transaction using [`delete_query_by_id`](Self::delete_query_by_id)
    /// 3. Maintains ACID properties within each batch
    ///
    /// # Performance Considerations
    ///
    /// Consider batch size carefully:
    /// - Too small: More overhead from multiple transactions
    /// - Too large: Higher memory usage and longer transaction times
    #[tracing::instrument(skip_all, level = "debug", parent = Self::repository_span())]
    async fn delete_batch<const N: usize>(
        &self,
        ids: impl IntoIterator<Item = M::Id>,
    ) -> crate::Result<()> {
        BatchOperator::<M::Id, N>::execute_query(ids, self.pool(), Self::delete_query_by_id).await
    }
}